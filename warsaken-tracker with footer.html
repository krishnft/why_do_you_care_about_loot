<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Warsaken Tracker</title>
<link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=DM+Mono:wght@400;500&family=Syne:wght@600;700;800&display=swap" rel="stylesheet">
<style>
*,*::before,*::after{margin:0;padding:0;box-sizing:border-box;}
:root{
  --bg:#070809;--bg2:#0c0e12;--surf:#111520;--surf2:#181d2b;
  --border:#1c2235;--bord2:#252e45;
  --gold:#d4a03a;--gold2:#f0be55;--gold3:#ffe08a;
  --green:#00d68f;--green2:#00b377;--red:#ff4d4d;
  --blue:#4da6ff;--purple:#a78bfa;--orange:#fb923c;
  --muted:#2e3a52;--text:#c2d0e8;--text2:#5c7299;--text3:#3d5070;
  --glow-g:rgba(200,150,50,.08);--glow-gr:rgba(0,214,143,.08);
}
body{background:var(--bg);color:var(--text);font-family:'Syne',sans-serif;min-height:100vh;overflow-x:hidden;}
body::before{content:'';position:fixed;inset:0;
  background:repeating-linear-gradient(0deg,transparent,transparent 2px,rgba(0,0,0,.03) 2px,rgba(0,0,0,.03) 4px),
    radial-gradient(ellipse 80% 60% at 50% 0%,rgba(212,160,58,.04) 0%,transparent 60%);
  pointer-events:none;z-index:0;}
.wrap{position:relative;z-index:1;max-width:1440px;margin:0 auto;padding:0 20px;}

/* HEADER */
header{border-bottom:1px solid var(--border);padding:13px 0;position:sticky;top:0;
  background:rgba(7,8,9,.97);backdrop-filter:blur(12px);z-index:100;}
.hdr{display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;}
.logo{display:flex;align-items:center;gap:12px;}
.logo-mark{width:34px;height:34px;border:2px solid var(--gold);display:flex;
  align-items:center;justify-content:center;font-family:'Bebas Neue',cursive;
  font-size:1rem;color:var(--gold2);position:relative;}
.logo-mark::after{content:'';position:absolute;inset:3px;border:1px solid rgba(212,160,58,.3);}
.logo-top{font-family:'DM Mono',monospace;font-size:.52rem;letter-spacing:4px;color:var(--text2);}
.logo-main{font-family:'Bebas Neue',cursive;font-size:1.45rem;letter-spacing:5px;
  color:var(--gold2);text-shadow:0 0 30px rgba(240,190,85,.25);}
.hdr-right{display:flex;align-items:center;gap:7px;flex-wrap:wrap;}

/* Price chips */
.pstrip{display:flex;align-items:center;gap:5px;flex-wrap:wrap;}
.pchip{display:flex;align-items:center;gap:5px;padding:4px 9px;
  background:var(--surf);border:1px solid var(--border);
  font-family:'DM Mono',monospace;font-size:.62rem;letter-spacing:1px;color:var(--text2);}
.pchip .sym{color:var(--gold);font-weight:500;}
.pchip .pv{color:var(--text);}
.chg{font-size:.58rem;}
.chg.up{color:var(--green);}.chg.dn{color:var(--red);}
.schip{display:flex;align-items:center;gap:5px;padding:4px 9px;
  border:1px solid var(--border);font-family:'DM Mono',monospace;
  font-size:.6rem;letter-spacing:2px;}
.schip.ok{border-color:var(--green2);color:var(--green);}
.schip.fail{border-color:var(--red);color:var(--red);}
.schip.spin{border-color:var(--gold);color:var(--gold);}
.dot{width:6px;height:6px;border-radius:50%;background:currentColor;flex-shrink:0;}
.dot.pulse{animation:blink 2s ease-in-out infinite;}
@keyframes blink{0%,100%{opacity:1}50%{opacity:.25}}

/* HERO */
.hero{display:grid;grid-template-columns:repeat(8,1fr);gap:1px;
  background:var(--border);border:1px solid var(--border);margin:16px 0;}
.hs{background:var(--surf);padding:13px 14px;position:relative;overflow:hidden;}
.hs::before{content:'';position:absolute;top:0;left:0;right:0;height:2px;background:var(--border);}
.hs.hl::before{background:linear-gradient(90deg,var(--gold),var(--gold2));}
.hs.hg::before{background:var(--green);}
.hs.hb::before{background:var(--blue);}
.hs.hp::before{background:var(--purple);}
.hs.ho::before{background:var(--orange);}
.hs-lbl{font-family:'DM Mono',monospace;font-size:.52rem;letter-spacing:3px;
  text-transform:uppercase;color:var(--text2);margin-bottom:4px;}
.hs-val{font-family:'Bebas Neue',cursive;font-size:1.45rem;letter-spacing:2px;
  line-height:1;color:var(--gold2);}
.hs-val.g{color:var(--green);}
.hs-val.m{color:var(--muted);}
.hs-val.b{color:var(--blue);}
.hs-val.p{color:var(--purple);}
.hs-val.o{color:var(--orange);}
.hs-sub{font-family:'DM Mono',monospace;font-size:.55rem;color:var(--text3);margin-top:3px;}

/* TOOLBAR */
.toolbar{display:flex;align-items:center;justify-content:space-between;
  gap:8px;margin-bottom:9px;flex-wrap:wrap;}
.tl{display:flex;align-items:center;gap:6px;flex-wrap:wrap;}
.sec-ttl{font-family:'Bebas Neue',cursive;font-size:.88rem;letter-spacing:4px;
  color:var(--text2);display:flex;align-items:center;gap:7px;}
.sec-ttl::before{content:'';width:2px;height:13px;background:var(--gold);}
.ftabs{display:flex;}
.ftab{padding:4px 12px;font-family:'Syne',sans-serif;font-size:.73rem;font-weight:700;
  letter-spacing:1px;text-transform:uppercase;border:1px solid var(--bord2);border-right:none;
  background:var(--surf);color:var(--text2);cursor:pointer;transition:all .15s;}
.ftab:last-child{border-right:1px solid var(--bord2);}
.ftab:hover{color:var(--text);}
.ftab.on{background:var(--gold);color:#000;font-weight:800;border-color:var(--gold);}
.sw{display:flex;border:1px solid var(--bord2);background:var(--surf);}
.sw input{background:transparent;border:none;color:var(--text);
  font-family:'DM Mono',monospace;font-size:.76rem;padding:4px 11px;outline:none;width:155px;}
.sw input::placeholder{color:var(--text3);}

/* BUTTONS */
.btn{display:inline-flex;align-items:center;gap:5px;padding:5px 13px;
  border:1px solid var(--gold);background:transparent;color:var(--gold);
  font-family:'Syne',sans-serif;font-size:.73rem;font-weight:700;
  letter-spacing:1px;text-transform:uppercase;cursor:pointer;transition:all .18s;border-radius:1px;}
.btn:hover{background:var(--glow-g);color:var(--gold2);}
.btn.prim{background:var(--gold);color:#000;}
.btn.prim:hover{background:var(--gold2);}
.btn.dng{border-color:var(--red);color:var(--red);}
.btn.dng:hover{background:rgba(255,77,77,.08);}
.btn.sm{padding:3px 10px;font-size:.68rem;}
.btn:disabled{opacity:.3;cursor:not-allowed;pointer-events:none;}

/* PANELS */
.panel{background:var(--surf);border:1px solid var(--bord2);border-left:3px solid var(--gold);
  padding:13px 16px;margin-bottom:9px;display:none;gap:9px;align-items:flex-end;flex-wrap:wrap;}
.panel.open{display:flex;}
.bulk-panel{background:var(--surf);border:1px solid var(--bord2);
  padding:13px 16px;margin-bottom:9px;display:none;}
.bulk-panel.open{display:block;}
.pf{display:flex;flex-direction:column;gap:4px;}
.pf label,.bp-label{font-family:'DM Mono',monospace;font-size:.52rem;letter-spacing:3px;
  text-transform:uppercase;color:var(--text2);}
.pf input,.bulk-panel textarea{background:var(--bg2);border:1px solid var(--bord2);color:var(--text);
  font-family:'DM Mono',monospace;font-size:.8rem;padding:6px 10px;
  outline:none;transition:border-color .2s;border-radius:1px;}
.pf input:focus,.bulk-panel textarea:focus{border-color:var(--gold);}
.pf input::placeholder,.bulk-panel textarea::placeholder{color:var(--text3);}
.pf input.w{width:195px;}.pf input.n{width:135px;}
.bulk-panel textarea{width:100%;min-height:85px;resize:vertical;margin:7px 0;}

/* PROGRESS */
.prog-wrap{margin-bottom:4px;display:none;}
.prog-bar{height:2px;background:var(--border);position:relative;overflow:hidden;}
.prog-fill{position:absolute;left:0;top:0;bottom:0;
  background:linear-gradient(90deg,var(--gold),var(--gold2));transition:width .3s ease;width:0%;}
.prog-txt{font-family:'DM Mono',monospace;font-size:.58rem;color:var(--text2);
  letter-spacing:2px;margin-top:3px;text-align:right;}

/* TABLE */
.tbl-wrap{border:1px solid var(--border);margin-bottom:16px;overflow-x:auto;}
table{width:100%;border-collapse:collapse;min-width:1150px;}
thead tr{background:var(--surf2);border-bottom:1px solid var(--bord2);}
th{font-family:'DM Mono',monospace;font-size:.52rem;letter-spacing:3px;text-transform:uppercase;
  color:var(--text2);padding:9px 11px;text-align:left;white-space:nowrap;cursor:pointer;
  user-select:none;transition:color .15s;}
th:hover{color:var(--gold);}
th.srt{color:var(--gold2);}
th .arr{margin-left:3px;font-size:.58rem;}
tbody tr{border-bottom:1px solid var(--border);transition:background .12s;animation:rIn .2s ease;}
@keyframes rIn{from{opacity:0;transform:translateY(3px)}to{opacity:1;transform:none}}
tbody tr:hover{background:rgba(212,160,58,.03);}
td{padding:9px 11px;font-size:.83rem;vertical-align:middle;}
tr.sc td:first-child{box-shadow:inset 3px 0 0 var(--green);}
tr.sd td:first-child{box-shadow:inset 3px 0 0 var(--muted);}
tr.sl td:first-child{box-shadow:inset 3px 0 0 var(--gold);}
tr.se td:first-child{box-shadow:inset 3px 0 0 var(--red);}
.wlt{font-family:'DM Mono',monospace;font-size:.8rem;color:var(--text);}
.ali{font-size:.68rem;color:var(--text2);margin-top:2px;}
.rbadge{display:inline-block;font-family:'Bebas Neue',cursive;font-size:.68rem;
  letter-spacing:2px;padding:2px 7px;border:1px solid;border-radius:1px;}
.r0{color:#3d5070;border-color:#3d5070;}.r1{color:#7a8fa8;border-color:#7a8fa8;}
.r2{color:#4ade80;border-color:#4ade80;}.r3{color:#60a5fa;border-color:#60a5fa;}
.r4{color:#a78bfa;border-color:#a78bfa;}.r5{color:var(--gold2);border-color:var(--gold2);}
.r6{color:#f87171;border-color:#f87171;}
.xpt{width:60px;height:3px;background:var(--bord2);border-radius:2px;margin-top:3px;overflow:hidden;}
.xpf{height:100%;border-radius:2px;transition:width 1s ease;
  background:linear-gradient(90deg,var(--gold),var(--gold2));}
.mn{font-family:'DM Mono',monospace;font-size:.79rem;}
.go{color:var(--gold2);}.gr{color:var(--green);}.bl{color:var(--blue);}
.pu{color:var(--purple);}.mu{color:var(--muted);}.or{color:var(--orange);}
.sv{font-family:'DM Mono',monospace;font-size:.6rem;color:var(--text3);margin-top:2px;}
.pill{display:inline-flex;align-items:center;gap:4px;font-family:'DM Mono',monospace;
  font-size:.58rem;letter-spacing:1px;text-transform:uppercase;padding:2px 7px;border-radius:2px;}
.pc{background:rgba(0,214,143,.1);color:var(--green);}
.pd{background:rgba(46,58,82,.4);color:var(--text2);}
.pl{background:rgba(212,160,58,.1);color:var(--gold);}
.pe{background:rgba(255,77,77,.1);color:var(--red);}
.pdot{width:4px;height:4px;border-radius:50%;background:currentColor;flex-shrink:0;}
.pl .pdot{animation:blink 1s infinite;}
.acts{display:flex;gap:4px;align-items:center;}
/* cache indicator */
.ci{display:inline-block;width:6px;height:6px;border-radius:50%;margin-left:4px;vertical-align:middle;}
.ci.fresh{background:var(--green);}.ci.stale{background:var(--orange);}
.ci.none{background:var(--text3);}
.shim{height:11px;border-radius:2px;width:58%;
  background:linear-gradient(90deg,var(--surf2) 25%,var(--bord2) 50%,var(--surf2) 75%);
  background-size:200% 100%;animation:shim 1.3s infinite;}
@keyframes shim{to{background-position:-200% 0}}
.empty{text-align:center;padding:48px 20px;color:var(--text2);}
.empty-icon{font-size:1.8rem;margin-bottom:8px;opacity:.3;}
.empty-ttl{font-family:'Bebas Neue',cursive;font-size:1.1rem;letter-spacing:4px;margin-bottom:5px;}
.empty-sub{font-size:.76rem;letter-spacing:1px;margin-bottom:14px;}
.log-body{background:var(--surf);border:1px solid var(--border);padding:9px 12px;
  max-height:105px;overflow-y:auto;font-family:'DM Mono',monospace;
  font-size:.66rem;line-height:1.85;color:var(--text2);margin-bottom:28px;}
.log-body::-webkit-scrollbar{width:2px;}
.log-body::-webkit-scrollbar-thumb{background:var(--bord2);}
.le{display:flex;gap:8px;}.lt{color:var(--text3);flex-shrink:0;}
.lm.s{color:var(--green);}.lm.e{color:var(--red);}
.lm.i{color:var(--gold);}.lm.w{color:#f59e0b;}
#toasts{position:fixed;bottom:14px;right:14px;z-index:200;
  display:flex;flex-direction:column;gap:5px;}
.toast{background:var(--surf2);border:1px solid var(--bord2);border-left:3px solid var(--gold);
  padding:8px 13px;font-family:'DM Mono',monospace;font-size:.71rem;letter-spacing:1px;
  min-width:210px;max-width:300px;animation:tin .22s ease;
  display:flex;gap:7px;align-items:flex-start;}
.toast.s{border-left-color:var(--green);}.toast.e{border-left-color:var(--red);}
@keyframes tin{from{opacity:0;transform:translateX(12px)}to{opacity:1;transform:none}}
@media(max-width:900px){
  .hero{grid-template-columns:repeat(4,1fr);}
  .ftabs{display:none;}
}
@media(max-width:500px){
  .hero{grid-template-columns:repeat(2,1fr);}
}

/* ─── FOOTER ─── */
footer {
  border-top: 1px solid var(--border);
  margin-top: 8px;
  padding: 40px 0 0;
  position: relative;
}
footer::before {
  content: '';
  position: absolute;
  top: -1px; left: 0;
  width: 120px; height: 1px;
  background: linear-gradient(90deg, var(--gold), transparent);
}
.footer-inner {
  display: grid;
  grid-template-columns: 1fr 1.6fr;
  gap: 48px;
  padding-bottom: 36px;
}
.footer-logo { display:flex; align-items:center; gap:12px; margin-bottom:16px; }
.footer-desc {
  font-family: 'DM Mono', monospace;
  font-size: .68rem; line-height: 1.8;
  color: var(--text3); max-width: 340px;
}
.footer-links { display:grid; grid-template-columns:repeat(3,1fr); gap:28px; }
.footer-col-title {
  font-family: 'Bebas Neue', cursive;
  font-size: .8rem; letter-spacing: 4px;
  color: var(--gold); margin-bottom: 14px;
  padding-bottom: 8px;
  border-bottom: 1px solid var(--border);
}
.footer-link {
  display: flex; align-items: center; gap: 8px;
  font-family: 'DM Mono', monospace;
  font-size: .73rem; color: var(--text2);
  text-decoration: none;
  margin-bottom: 10px;
  padding: 6px 10px;
  border: 1px solid var(--border);
  transition: all .2s;
}
.footer-link:hover {
  color: var(--gold2);
  border-color: var(--gold);
  background: var(--glow-g);
}
.footer-link svg { flex-shrink: 0; opacity: .7; }
.footer-link:hover svg { opacity: 1; }
.footer-note {
  font-family: 'DM Mono', monospace;
  font-size: .65rem; line-height: 1.8;
  color: var(--text3); margin-bottom: 12px;
}
.footer-cta {
  display: inline-block;
  font-family: 'DM Mono', monospace;
  font-size: .7rem; letter-spacing: 1px;
  color: var(--gold);
  text-decoration: none;
  transition: color .2s;
}
.footer-cta:hover { color: var(--gold2); text-decoration: underline; }
.donate-box {
  background: var(--surf2);
  border: 1px solid var(--bord2);
  border-left: 2px solid var(--gold);
  padding: 10px 12px;
}
.donate-label {
  font-family: 'DM Mono', monospace;
  font-size: .52rem; letter-spacing: 3px; text-transform: uppercase;
  color: var(--text3); margin-bottom: 5px;
}
.donate-addr {
  font-family: 'DM Mono', monospace;
  font-size: .88rem; color: var(--gold2);
  cursor: pointer; display: flex;
  align-items: center; justify-content: space-between;
  gap: 8px;
  transition: color .2s;
}
.donate-addr:hover { color: var(--gold3); }
.copy-hint {
  font-size: .55rem; color: var(--text3);
  letter-spacing: 1px; text-transform: uppercase;
}
.donate-confirm {
  font-family: 'DM Mono', monospace;
  font-size: .62rem; color: var(--green);
  margin-top: 4px; height: 14px;
  transition: opacity .3s;
}
.footer-bottom {
  border-top: 1px solid var(--border);
  padding: 14px 0;
  display: flex; align-items: center; justify-content: space-between;
  flex-wrap: wrap; gap: 8px;
  font-family: 'DM Mono', monospace;
  font-size: .6rem; letter-spacing: 1px;
  color: var(--text3);
}
@media(max-width:900px) {
  .footer-inner { grid-template-columns: 1fr; gap: 28px; }
  .footer-links { grid-template-columns: 1fr; }
  .footer-bottom { flex-direction: column; gap: 4px; }
}
</style>
</head>
<body>
<div id="toasts"></div>

<header>
  <div class="wrap">
    <div class="hdr">
      <div class="logo">
        <div class="logo-mark">W</div>
        <div>
          <div class="logo-top">Warsaken</div>
          <div class="logo-main">Loot Tracker</div>
        </div>
      </div>
      <div class="hdr-right">
        <div class="pstrip">
          <div class="pchip" title="WAX/USD from CoinGecko">
            <span class="sym">WAX</span>
            <span class="pv" id="wax-p">—</span>
            <span id="wax-chg"></span>
          </div>
          <div class="pchip" title="LOOT/WAX from Alcor DEX">
            <span class="sym">LOOT</span>
            <span class="pv" id="loot-p">—</span>
            <span class="pv" style="color:var(--text3);margin-left:2px" id="loot-wax">—</span>
            <span id="loot-chg"></span>
          </div>
        </div>
        <div class="schip spin" id="api-chip">
          <span class="dot pulse"></span>
          <span id="api-txt">CONNECTING</span>
        </div>
        <div class="schip ok" style="border-color:var(--border);color:var(--text2)">
          <span class="dot pulse" style="color:var(--green)"></span>
          <span id="clock">--:--:-- UTC</span>
        </div>
      </div>
    </div>
  </div>
</header>

<div class="wrap" style="padding-top:14px">

  <div class="hero">
    <div class="hs">
      <div class="hs-lbl">Accounts</div>
      <div class="hs-val" id="h-accs">0</div>
      <div class="hs-sub" id="h-accs-sub">0 claimable</div>
    </div>
    <div class="hs hg">
      <div class="hs-lbl">Claimable</div>
      <div class="hs-val g" id="h-claim">0</div>
      <div class="hs-sub" id="h-done-sub">0 already claimed</div>
    </div>
    <div class="hs">
      <div class="hs-lbl">Total NFTs</div>
      <div class="hs-val" id="h-nfts">0</div>
      <div class="hs-sub">warsaken collection only</div>
    </div>
    <div class="hs hl">
      <div class="hs-lbl">Total LOOT Balance</div>
      <div class="hs-val" id="h-loot">0</div>
      <div class="hs-sub" id="h-loot-usd">≈ $0 USD</div>
    </div>
    <div class="hs hb">
      <div class="hs-lbl">Total WAX (All)</div>
      <div class="hs-val b" id="h-wax">0</div>
      <div class="hs-sub" id="h-wax-usd">≈ $0 USD</div>
    </div>
    <div class="hs hb">
      <div class="hs-lbl">Staked WAX</div>
      <div class="hs-val b" id="h-staked">0</div>
      <div class="hs-sub">CPU + NET staked</div>
    </div>
    <div class="hs hp">
      <div class="hs-lbl">Daily LOOT</div>
      <div class="hs-val p" id="h-daily">0</div>
      <div class="hs-sub" id="h-daily-usd">from on-chain txns</div>
    </div>
    <div class="hs ho">
      <div class="hs-lbl">Daily LOOT → WAX</div>
      <div class="hs-val o" id="h-daily-wax">0</div>
      <div class="hs-sub" id="h-daily-wax-usd">≈ $0 USD/day</div>
    </div>
  </div>

  <div class="toolbar">
    <div class="tl">
      <div class="sec-ttl">Accounts</div>
      <div class="ftabs">
        <button class="ftab on" onclick="setF('all',this)">All</button>
        <button class="ftab" onclick="setF('claimable',this)">Claimable</button>
        <button class="ftab" onclick="setF('claimed',this)">Claimed</button>
      </div>
      <div class="sw"><input id="search" type="text" placeholder="Search wallet..." oninput="renderTable()"/></div>
    </div>
    <div style="display:flex;gap:5px;flex-wrap:wrap;">
      <button class="btn sm" onclick="togBulk()">⬆ Bulk Import</button>
      <button class="btn sm" onclick="togAdd()">＋ Add</button>
      <button class="btn sm" id="btn-ra" onclick="refreshAll()" style="display:none">↻ Refresh All</button>
      <button class="btn sm" onclick="exportData()" title="Export wallets + cached data to JSON">⬇ Export</button>
      <button class="btn sm" onclick="document.getElementById('import-file').click()" title="Import from exported JSON">⬆ Import JSON</button>
      <input type="file" id="import-file" accept=".json" style="display:none" onchange="importData(event)"/>
      <button class="btn sm dng" id="btn-cl" onclick="clearAll()" style="display:none">✕ Clear</button>
    </div>
  </div>

  <div class="panel" id="add-panel">
    <div class="pf"><label>WAX Wallet</label>
      <input class="w" id="inp-w" type="text" placeholder="e.g. vtbuq.wam" autocomplete="off"/></div>
    <div class="pf"><label>Nickname</label>
      <input class="n" id="inp-a" type="text" placeholder="optional"/></div>
    <button class="btn prim sm" onclick="addOne()">Add</button>
    <button class="btn sm" onclick="togAdd()">Cancel</button>
  </div>

  <div class="bulk-panel" id="bulk-panel">
    <div class="bp-label" style="margin-bottom:4px">One wallet per line · Optional nickname after comma:
      <span style="color:var(--gold);font-family:'DM Mono',monospace"> vtbuq.wam, Main</span>
    </div>
    <textarea id="bulk-ta" placeholder="vtbuq.wam&#10;nn2hc.wam, Account 2&#10;renzotheboss, Boss&#10;..."></textarea>
    <div style="display:flex;gap:7px;">
      <button class="btn prim sm" onclick="bulkImport()">Import</button>
      <button class="btn sm" onclick="togBulk()">Cancel</button>
    </div>
  </div>

  <!-- EXPORT/IMPORT MODAL -->
  <div id="ei-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.75);
    z-index:200;align-items:center;justify-content:center;backdrop-filter:blur(6px);">
    <div style="background:var(--surf2);border:1px solid var(--gold);padding:28px;
      width:100%;max-width:460px;position:relative;box-shadow:0 0 40px rgba(212,160,58,.15);
      margin:20px;">
      <button onclick="closeEI()" style="position:absolute;top:12px;right:14px;background:none;
        border:none;color:var(--text2);font-size:1.1rem;cursor:pointer;line-height:1;">✕</button>
      <div style="font-family:'Bebas Neue',cursive;font-size:1.3rem;letter-spacing:4px;
        color:var(--gold2);margin-bottom:4px;" id="ei-title">EXPORT</div>
      <div style="font-family:'DM Mono',monospace;font-size:.72rem;color:var(--text2);
        margin-bottom:16px;" id="ei-sub">Copy this JSON and save it somewhere safe</div>
      <textarea id="ei-ta" style="width:100%;background:var(--bg);border:1px solid var(--bord2);
        color:var(--text);font-family:'DM Mono',monospace;font-size:.72rem;
        padding:10px 12px;outline:none;resize:vertical;min-height:160px;
        border-radius:1px;margin-bottom:12px;" readonly></textarea>
      <div style="display:flex;gap:8px;" id="ei-actions">
        <button class="btn prim sm" onclick="copyExport()">⎘ Copy to Clipboard</button>
        <button class="btn sm" onclick="downloadExport()">⬇ Download File</button>
        <button class="btn sm" onclick="closeEI()">Close</button>
      </div>
    </div>
  </div>

  <div class="prog-wrap" id="prog-wrap">
    <div class="prog-bar"><div class="prog-fill" id="prog-fill"></div></div>
    <div class="prog-txt" id="prog-txt"></div>
  </div>

  <div class="tbl-wrap">
    <table>
      <thead>
        <tr>
          <th onclick="srt('wallet')">Wallet <span class="arr">↕</span></th>
          <th onclick="srt('rank')">Rank <span class="arr">↕</span></th>
          <th onclick="srt('nfts')">NFTs <span class="arr">↕</span></th>
          <th onclick="srt('xp')">XP <span class="arr">↕</span> <span title="Cached 30 days" style="font-size:.5rem;color:var(--text3)">[~30d]</span></th>
          <th onclick="srt('daily')">Daily LOOT <span class="arr">↕</span> <span title="Cached 48 hours" style="font-size:.5rem;color:var(--text3)">[48h]</span></th>
          <th onclick="srt('loot')">LOOT Bal <span class="arr">↕</span></th>
          <th onclick="srt('waxTotal')">WAX Total <span class="arr">↕</span></th>
          <th onclick="srt('waxLiquid')">WAX Liquid <span class="arr">↕</span></th>
          <th onclick="srt('waxStaked')">WAX Staked <span class="arr">↕</span></th>
          <th onclick="srt('status')">Status <span class="arr">↕</span></th>
          <th onclick="srt('lastClaim')">Last Claim <span class="arr">↕</span></th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="tbl-body"></tbody>
    </table>
  </div>

  <div class="toolbar" style="margin-bottom:6px">
    <div class="sec-ttl">Activity Log</div>
    <button class="btn sm" onclick="clearLog()">Clear</button>
  </div>
  <div class="log-body" id="log">
    <div class="le"><span class="lt">[INIT]</span><span class="lm i">Warsaken Tracker v6 — ready</span></div>
  </div>

</div>

<!-- FOOTER -->
<footer>
  <div class="wrap">
    <div class="footer-inner">

      <div class="footer-left">
        <div class="footer-logo">
          <div class="logo-mark" style="width:28px;height:28px;font-size:.85rem;">W</div>
          <div>
            <div style="font-family:'Bebas Neue',cursive;font-size:1rem;letter-spacing:4px;color:var(--gold2);">Warsaken Loot Tracker</div>
            <div style="font-family:'DM Mono',monospace;font-size:.55rem;letter-spacing:2px;color:var(--text3);">Built by krish the Bot Builder · WAX Blockchain</div>
          </div>
        </div>
        <p class="footer-desc">
          Useful in tracking Warsaken loot claims, NFT counts, WAX balances and daily earnings  — all from your browser.
        </p>
      </div>

      <div class="footer-links">

        <div class="footer-col">
          <div class="footer-col-title">Get In Touch</div>
          <a href="https://twitter.com/krishnftlover" target="_blank" rel="noopener" class="footer-link">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor"><path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-4.714-6.231-5.401 6.231H2.744l7.737-8.835L1.254 2.25H8.08l4.253 5.622 5.91-5.622zm-1.161 17.52h1.833L7.084 4.126H5.117z"/></svg>
            @krishnftlover
          </a>
          <a href="https://discord.com/users/_krish_" target="_blank" rel="noopener" class="footer-link">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="currentColor"><path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0 12.64 12.64 0 0 0-.617-1.25.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057c.002.022.015.043.032.054a19.9 19.9 0 0 0 5.993 3.03.078.078 0 0 0 .084-.028 14.09 14.09 0 0 0 1.226-1.994.076.076 0 0 0-.041-.106 13.107 13.107 0 0 1-1.872-.892.077.077 0 0 1-.008-.128 10.2 10.2 0 0 0 .372-.292.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127 12.299 12.299 0 0 1-1.873.892.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028 19.839 19.839 0 0 0 6.002-3.03.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.956-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419 0-1.333.955-2.419 2.157-2.419 1.21 0 2.176 1.096 2.157 2.42 0 1.333-.946 2.418-2.157 2.418z"/></svg>
            _krish_
          </a>
        </div>

        <div class="footer-col">
          <div class="footer-col-title">Open for work</div>
          <div class="footer-note">
            Need a custom tool for WAX, EOS, or any blockchain? I build dashboards, trackers, automation tools and DeFi utilities.
          </div>
          <a href="https://twitter.com/krishnftlover" target="_blank" rel="noopener" class="footer-cta">
            → DM me on Twitter
          </a>
        </div>

        <div class="footer-col">
          <div class="footer-col-title">Support This Tool</div>
          <div class="footer-note">If this tracker saves you time, pour some wax — it keeps the tools coming!</div>
          <div class="donate-box">
            <div class="donate-label">WAX Wallet</div>
            <div class="donate-addr" onclick="copyWallet()" title="Click to copy">
              zh3b2.wam
              <span class="copy-hint">click to copy</span>
            </div>
            <div class="donate-confirm" id="donate-confirm"></div>
          </div>
        </div>

      </div>
    </div>

    <div class="footer-bottom">
      <span>© 2026 Warsaken Tracker · Built with ♥ for the WAX community</span>
      <span>Data sourced from AtomicAssets API · WAX Blockchain · Alcor DEX</span>
    </div>
  </div>
</footer>

<script>
'use strict';

// ═══════════════════════════════════════════════════════════════
//  CONFIG
// ═══════════════════════════════════════════════════════════════
const BATCH       = 5;
const PRICE_TTL   = 60_000;       // price cache: 60s
const DAILY_TTL   = 48*3600_000;  // daily loot cache: 48 hours
const XP_TTL      = 30*24*3600_000; // XP cache: 30 days
const LOOT_PER_XP = 0.003713;     // calibrated from screenshot

// Rank thresholds (observed from warsaken screenshots)
const RANKS = [
  {label:'ENLISTED',   minXP:0,          cls:'r1'},
  {label:'CORPORAL',   minXP:50_000,      cls:'r2'},
  {label:'SERGEANT',   minXP:200_000,     cls:'r3'},
  {label:'LIEUTENANT', minXP:1_000_000,   cls:'r4'},
  {label:'CAPTAIN',    minXP:4_000_000,   cls:'r5'},
  {label:'GENERAL',    minXP:10_000_000,  cls:'r6'},
];
const getRank = xp => {
  for (let i=RANKS.length-1; i>=0; i--)
    if (xp >= RANKS[i].minXP) return {...RANKS[i], idx:i};
  return {...RANKS[0], idx:0};
};

// ═══════════════════════════════════════════════════════════════
//  ENDPOINTS
// ═══════════════════════════════════════════════════════════════
const AA_NODES = [
  'https://wax.api.atomicassets.io',
  'https://aa.dapplica.io',
  'https://atomic.wax.eosrio.io',
  'https://aa.waxsweden.org',
];
const WAX_NODES = [
  'https://api.waxsweden.org',
  'https://wax.eosusa.io',
  'https://wax.pink.gg',
  'https://wax.blokcrafters.io',
  'https://wax.eu.eosamsterdam.net',
];

let AA_EP=null, WAX_EP=null, apiOk=false;

// ═══════════════════════════════════════════════════════════════
//  PRICE STATE  — LOOT priced in WAX from Alcor, WAX in USD from CoinGecko
// ═══════════════════════════════════════════════════════════════
const PC = {waxUsd:0, lootWax:0, lootUsd:0, waxChg:0, lootChg:0, ts:0};

async function fetchPrices() {
  if (Date.now() - PC.ts < PRICE_TTL) return;

  // ── WAX/USD from CoinGecko ──
  try {
    const r = await fetch(
      'https://api.coingecko.com/api/v3/simple/price?ids=wax&vs_currencies=usd&include_24hr_change=true',
      {signal:AbortSignal.timeout(6000)}
    );
    if (r.ok) {
      const d = await r.json();
      PC.waxUsd = d?.wax?.usd || 0;
      PC.waxChg = d?.wax?.usd_24h_change || 0;
    }
  } catch(e) { log(`WAX price fail: ${e.message}`,'w'); }

  // ── LOOT/WAX price — try 3 sources in order ──
  let lootWax = 0;

  // Source 1: wax.alcor.exchange (correct subdomain)
  if (!lootWax) {
    try {
      const r = await fetch(
        'https://wax.alcor.exchange/api/v2/tickers/loot-warsaken_wax-eosio.token',
        {signal:AbortSignal.timeout(6000)}
      );
      if (r.ok) {
        const d = await r.json();
        // Alcor ticker response: {last_price, bid, ask, change24, ...}
        lootWax = parseFloat(d?.last_price ?? d?.price ?? d?.bid ?? 0);
        if (lootWax > 0) {
          if (d?.change24) PC.lootChg = d.change24;
          log(`LOOT price [wax.alcor.exchange]: ${lootWax.toFixed(8)} WAX`,'s');
        }
      }
    } catch(e) { log(`Alcor source 1 fail: ${e.message}`,'w'); }
  }

  // Source 2: alcor.exchange (fallback subdomain)
  if (!lootWax) {
    try {
      const r = await fetch(
        'https://alcor.exchange/api/v2/tickers/loot-warsaken_wax-eosio.token',
        {signal:AbortSignal.timeout(6000)}
      );
      if (r.ok) {
        const d = await r.json();
        lootWax = parseFloat(d?.last_price ?? d?.price ?? 0);
        if (lootWax > 0) log(`LOOT price [alcor.exchange]: ${lootWax.toFixed(8)} WAX`,'s');
      }
    } catch(e) { log(`Alcor source 2 fail: ${e.message}`,'w'); }
  }

  // Source 3: Alcor all tickers list — scan for LOOT/WAX pair
  if (!lootWax) {
    try {
      const r = await fetch('https://wax.alcor.exchange/api/v2/tickers',
        {signal:AbortSignal.timeout(8000)});
      if (r.ok) {
        const tickers = await r.json();
        const pair = tickers.find(t =>
          (t.ticker_id||'').toLowerCase().includes('loot-warsaken') ||
          (t.base_currency||'').toLowerCase().includes('loot') ||
          (t.global_ticker_id||'').toLowerCase() === 'loot_wax'
        );
        if (pair) {
          lootWax = parseFloat(pair.last_price ?? pair.price ?? 0);
          if (lootWax > 0) log(`LOOT price [tickers scan]: ${lootWax.toFixed(8)} WAX`,'s');
        }
      }
    } catch(e) { log(`Alcor tickers scan fail: ${e.message}`,'w'); }
  }

  // Source 4: Alcor AMM pools table via WAX chain (most reliable, always works)
  if (!lootWax) {
    try {
      const r = await fetch(`${WAX_EP||WAX_NODES[0]}/v1/chain/get_table_rows`, {
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body: JSON.stringify({
          code:'alcordexmain', scope:'alcordexmain', table:'markets',
          limit:200, json:true
        }),
        signal:AbortSignal.timeout(8000)
      });
      if (r.ok) {
        const d = await r.json();
        const lootMkt = (d?.rows||[]).find(m =>
          (m?.quote_token?.sym||'').includes('LOOT') ||
          (m?.base_token?.sym||'').includes('LOOT')
        );
        if (lootMkt) {
          // On-chain market — get best bid price
          const bid = parseFloat(lootMkt.min_buy);
          if (bid > 0) { lootWax=bid; log(`LOOT price [on-chain market]: ${lootWax.toFixed(8)} WAX`,'s'); }
        }
      }
    } catch(e) { log(`On-chain price fail: ${e.message}`,'w'); }
  }

  PC.lootWax = lootWax;
  PC.lootUsd = lootWax * PC.waxUsd;
  PC.ts = Date.now();
  renderPrices();

  if (PC.waxUsd || PC.lootWax) {
    log(`Prices: WAX=$${PC.waxUsd.toFixed(4)} · LOOT=${PC.lootWax.toFixed(8)} WAX ≈ $${PC.lootUsd.toFixed(8)}`,'s');
  } else {
    log(`Price fetch failed — all sources returned 0`,'e');
  }
}

function renderPrices() {
  const fmtChg = v => v ? `<span class="chg ${v>0?'up':'dn'}">${v>0?'+':''}${v.toFixed(2)}%</span>` : '';
  document.getElementById('wax-p').textContent = PC.waxUsd ? `$${PC.waxUsd.toFixed(4)}` : '—';

  // Show LOOT as: "0.00012 WAX" primary, "$0.0000007" secondary
  if (PC.lootWax) {
    document.getElementById('loot-p').textContent  = `${PC.lootWax.toFixed(6)} WAX`;
    document.getElementById('loot-wax').textContent = PC.lootUsd ? `≈$${PC.lootUsd.toFixed(7)}` : '';
  } else {
    document.getElementById('loot-p').textContent  = '—';
    document.getElementById('loot-wax').textContent = 'fetching...';
  }
  document.getElementById('wax-chg').innerHTML  = fmtChg(PC.waxChg);
  document.getElementById('loot-chg').innerHTML = fmtChg(PC.lootChg);
}

const toUSD  = (v, price) => { if(!price||!v) return ''; const u=v*price; return u>=1000?`$${(u/1000).toFixed(1)}k`:u>=1?`$${u.toFixed(2)}`:`$${u.toFixed(4)}`; };
const toWAX  = (loot) => (PC.lootWax && loot) ? loot * PC.lootWax : 0;
const waxToUSD = (wax) => toUSD(wax, PC.waxUsd);

// ═══════════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════════
let accounts=[], activeF='all', srtKey='loot', srtDir=-1, busy=false;
try { accounts=JSON.parse(localStorage.getItem('wsn_v6')||'[]'); } catch(e){}
const save=()=>localStorage.setItem('wsn_v6',JSON.stringify(accounts));

// ═══════════════════════════════════════════════════════════════
//  UTILITIES
// ═══════════════════════════════════════════════════════════════
const pad   = v=>String(v).padStart(2,'0');
const num   = (v,d=1)=>isNaN(v)||v===null?'0':Number(v).toLocaleString('en',{maximumFractionDigits:d});
const sleep = ms=>new Promise(r=>setTimeout(r,ms));

setInterval(()=>{
  const n=new Date();
  document.getElementById('clock').textContent=
    `${pad(n.getUTCHours())}:${pad(n.getUTCMinutes())}:${pad(n.getUTCSeconds())} UTC`;
},1000);

// ═══════════════════════════════════════════════════════════════
//  LOG / TOAST
// ═══════════════════════════════════════════════════════════════
function log(msg,t='i'){
  const el=document.getElementById('log');
  const n=new Date();
  const ts=`[${pad(n.getUTCHours())}:${pad(n.getUTCMinutes())}:${pad(n.getUTCSeconds())}]`;
  const r=document.createElement('div');
  r.className='le';
  r.innerHTML=`<span class="lt">${ts}</span><span class="lm ${t}">${msg}</span>`;
  el.appendChild(r);el.scrollTop=el.scrollHeight;
}
function clearLog(){document.getElementById('log').innerHTML='';log('Log cleared.');}
function toast(msg,t=''){
  const tc=document.getElementById('toasts');
  const el=document.createElement('div');
  el.className=`toast ${t}`;
  el.innerHTML=`<span>${t==='s'?'✓':t==='e'?'✕':'ℹ'}</span><span>${msg}</span>`;
  tc.appendChild(el);setTimeout(()=>el.remove(),4000);
}

// ═══════════════════════════════════════════════════════════════
//  ENDPOINT DISCOVERY
// ═══════════════════════════════════════════════════════════════
async function probe(url){
  try{const r=await fetch(url,{signal:AbortSignal.timeout(4000)});return r.ok;}
  catch(e){return false;}
}
async function findEndpoints(){
  setChip('spin','CONNECTING');
  const [aa,wax]=await Promise.all([
    (async()=>{
      for(const ep of AA_NODES){
        if(await probe(`${ep}/atomicassets/v1/config`)){AA_EP=ep;log(`AA: ${ep}`,'s');return true;}
      }
      log('No AA node','e');return false;
    })(),
    (async()=>{
      for(const ep of WAX_NODES){
        if(await probe(`${ep}/v1/chain/get_info`)){WAX_EP=ep;log(`WAX: ${ep}`,'s');return true;}
      }
      log('No WAX node','e');return false;
    })()
  ]);
  apiOk=aa;
  setChip(aa?'ok':'fail',aa?'ONLINE':'OFFLINE');
  if(!aa) toast('Cannot reach WAX APIs','e');
  return aa;
}
function setChip(cls,txt){
  const c=document.getElementById('api-chip');
  c.className=`schip ${cls}`;
  c.querySelector('.dot').className=`dot${cls==='spin'?' pulse':''}`;
  document.getElementById('api-txt').textContent=txt;
}

// ═══════════════════════════════════════════════════════════════
//  HTTP HELPERS
// ═══════════════════════════════════════════════════════════════
async function aaGet(path){
  const nodes=AA_EP?[AA_EP,...AA_NODES.filter(n=>n!==AA_EP)]:AA_NODES;
  for(const ep of nodes){
    try{
      const r=await fetch(`${ep}${path}`,{signal:AbortSignal.timeout(8000)});
      if(r.ok){AA_EP=ep;return r.json();}
    }catch(e){}
  }
  return null;
}
async function waxPost(path,body){
  const nodes=WAX_EP?[WAX_EP,...WAX_NODES.filter(n=>n!==WAX_EP)]:WAX_NODES;
  for(const ep of nodes){
    try{
      const r=await fetch(`${ep}${path}`,{
        method:'POST',headers:{'Content-Type':'application/json'},
        body:JSON.stringify(body),signal:AbortSignal.timeout(8000)
      });
      if(r.ok){WAX_EP=ep;return r.json();}
    }catch(e){}
  }
  return null;
}
async function waxGet(path){
  const nodes=WAX_EP?[WAX_EP,...WAX_NODES.filter(n=>n!==WAX_EP)]:WAX_NODES;
  for(const ep of nodes){
    try{
      const r=await fetch(`${ep}${path}`,{signal:AbortSignal.timeout(8000)});
      if(r.ok) return r.json();
    }catch(e){}
  }
  return null;
}

// ═══════════════════════════════════════════════════════════════
//  FETCH NFT COUNT — bulletproof, handles 30k+ NFTs
//
//  Root cause of 0 for large wallets:
//  - count=true times out server-side for 30k+ assets
//  - accounts/${wallet} is wrong URL shape for this API
//
//  Strategy waterfall (fastest → most reliable):
//  1. /v1/accounts?owner&collection_name  → pre-aggregated per-collection summary
//     Response: [{account, assets, collections:[{collection_name, assets}]}]
//     This is O(1) on the server regardless of NFT count — works for 30k+
//  2. /v1/templates?collection_name&authorized_account (count owned templates)
//     Fallback if accounts endpoint is flaky
//  3. Paginated /v1/assets with limit=1000 — last resort, slower but guaranteed
// ═══════════════════════════════════════════════════════════════
async function fetchNFTCount(wallet){

  // ── Strategy 1: accounts summary — O(1), handles any size ──
  // Returns array where each item = {account, assets (total), collections:[...]}
  const s1 = await aaGet(
    `/atomicassets/v1/accounts?owner=${wallet}&collection_name=warsaken&limit=1`
  );
  if (s1?.data?.length) {
    const row = s1.data[0];
    // The response shape: row.assets = total across all collections
    // row.collections = [{collection_name, assets}] per collection
    // We want only warsaken
    if (Array.isArray(row.collections)) {
      const col = row.collections.find(c =>
        c.collection_name === 'warsaken' || c.collection?.collection_name === 'warsaken'
      );
      if (col) { log(`NFT count [accounts/collections] ${wallet} → ${col.assets}`,'s'); return parseInt(col.assets)||0; }
    }
    // If no collections breakdown, row.assets IS the warsaken count (we filtered by collection)
    if (row.assets !== undefined) {
      const n = parseInt(row.assets)||0;
      if (n > 0) { log(`NFT count [accounts/assets] ${wallet} → ${n}`,'s'); return n; }
    }
  }

  // ── Strategy 2: count=true with extended timeout (15s) ──
  // Works for moderate collections, may timeout on 30k+
  try {
    const nodes = AA_EP ? [AA_EP,...AA_NODES.filter(n=>n!==AA_EP)] : AA_NODES;
    for (const ep of nodes) {
      try {
        const r = await fetch(
          `${ep}/atomicassets/v1/assets?owner=${wallet}&collection_name=warsaken&count=true`,
          { signal: AbortSignal.timeout(15000) } // 15s — generous for large wallets
        );
        if (r.ok) {
          const d = await r.json();
          if (typeof d === 'number' && d >= 0) {
            log(`NFT count [count=true] ${wallet} → ${d}`,'s'); return d;
          }
          // Some nodes wrap it: {success:true, data: number}
          if (typeof d?.data === 'number') {
            log(`NFT count [count=true/wrapped] ${wallet} → ${d.data}`,'s'); return d.data;
          }
        }
      } catch(e) { /* try next node */ }
    }
  } catch(e) {}

  // ── Strategy 3: paginated fetch — guaranteed correct, slower ──
  // For 30k NFTs this is ~30 calls but will not fail
  log(`NFT count [paginated fallback] ${wallet} — counting pages...`,'w');
  let total = 0, page = 1;
  while (true) {
    const d = await aaGet(
      `/atomicassets/v1/assets?owner=${wallet}&collection_name=warsaken&limit=1000&page=${page}`
    );
    if (!d?.data) break;
    total += d.data.length;
    if (d.data.length < 1000) break; // last page
    page++;
    await sleep(100); // be polite on large wallets
  }
  log(`NFT count [paginated] ${wallet} → ${total} (${page} pages)`,'s');
  return total;
}

// ═══════════════════════════════════════════════════════════════
//  FETCH XP — cached 30 days (XP barely changes)
// ═══════════════════════════════════════════════════════════════
const XP_TABLES=['players','accounts','members','userxp','nftowners','stakers'];
async function fetchXP(wallet){
  for(const table of XP_TABLES){
    for(const scope of ['warsaken',wallet]){
      const d=await waxPost('/v1/chain/get_table_rows',{
        code:'warsaken',scope,table,
        lower_bound:wallet,upper_bound:wallet,
        limit:1,json:true,key_type:'name',index_position:'primary'
      });
      if(d?.rows?.length){
        const row=d.rows[0];
        const xp=parseInt(row.xp??row.total_xp??row.experience??row.XP??0);
        if(xp>0){log(`XP [${table}/${scope}] ${wallet} → ${xp.toLocaleString()}`,'s');return xp;}
      }
    }
  }
  return 0;
}

// ═══════════════════════════════════════════════════════════════
//  FETCH DAILY LOOT — cached 48 hours
//  Reads last warsaken:transfer with memo="Claim" for this wallet
//  from WAX transaction history. This is the ACTUAL observed loot.
// ═══════════════════════════════════════════════════════════════
async function fetchDailyLoot(wallet){
  // v2 history: get the most recent warsaken→transfer to this wallet with memo Claim
  const h=await waxGet(
    `/v2/history/get_actions?account=${wallet}&filter=warsaken%3Atransfer&limit=20&sort=desc`
  );
  if(h?.actions?.length){
    for(const action of h.actions){
      const data=action.act?.data || action.action_trace?.act?.data || {};
      const memo=data.memo||'';
      const to=data.to||'';
      const from=data.from||'';
      const qty=data.quantity||'';
      // Must be: from=warsaken, to=this wallet, memo=Claim
      if((from==='warsaken'||from==='warsaken ')&&
         (to===wallet)&&
         (memo.toLowerCase().includes('claim'))&&
         qty.includes('LOOT')){
        const amount=parseFloat(qty.split(' ')[0]);
        if(!isNaN(amount)&&amount>0){
          log(`Daily LOOT [history] ${wallet} → ${amount.toLocaleString()}`,'s');
          return amount;
        }
      }
    }
  }
  // Fallback: estimate from XP
  return 0;
}

// ═══════════════════════════════════════════════════════════════
//  FETCH LOOT BALANCE
// ═══════════════════════════════════════════════════════════════
async function fetchLootBal(wallet){
  for(const code of ['warsaken','loot.warsaken']){
    const d=await waxPost('/v1/chain/get_currency_balance',{code,account:wallet,symbol:'LOOT'});
    if(Array.isArray(d)&&d.length){
      const v=parseFloat(d[0]);
      if(!isNaN(v)) return v;
    }
  }
  return 0;
}

// ═══════════════════════════════════════════════════════════════
//  FETCH WAX BALANCES — liquid + CPU staked + NET staked
// ═══════════════════════════════════════════════════════════════
async function fetchWAX(wallet){
  const d=await waxPost('/v1/chain/get_account',{account_name:wallet});
  if(!d) return{liquid:0,cpu:0,net:0,staked:0,total:0};
  const liquid=parseFloat(d.core_liquid_balance?.split(' ')[0])||0;
  const cpu   =parseFloat(d.self_delegated_bandwidth?.cpu_weight?.split(' ')[0])||0;
  const net   =parseFloat(d.self_delegated_bandwidth?.net_weight?.split(' ')[0])||0;
  return{liquid,cpu,net,staked:cpu+net,total:liquid+cpu+net};
}

// ═══════════════════════════════════════════════════════════════
//  FETCH CLAIM STATUS
// ═══════════════════════════════════════════════════════════════
function isTodayUTC(ts){
  try{
    const d=new Date(ts.includes('T')||ts.endsWith('Z')?ts:ts+'Z');
    const n=new Date();
    return d.getUTCFullYear()===n.getUTCFullYear()&&
           d.getUTCMonth()===n.getUTCMonth()&&
           d.getUTCDate()===n.getUTCDate();
  }catch(e){return false;}
}
async function fetchClaimStatus(wallet){
  const h=await waxGet(`/v2/history/get_actions?account=${wallet}&filter=warsaken%3Aclaim&limit=1&sort=desc`);
  if(h?.actions?.length){
    const ts=h.actions[0].timestamp||h.actions[0]['@timestamp'];
    if(ts) return{claimed:isTodayUTC(ts),lastClaim:ts};
  }
  for(const table of ['claims','loots','claimlog']){
    const d=await waxPost('/v1/chain/get_table_rows',{
      code:'warsaken',scope:'warsaken',table,
      lower_bound:wallet,upper_bound:wallet,limit:1,json:true
    });
    if(d?.rows?.length){
      const ts=d.rows[0].last_claim??d.rows[0].lastclaim??d.rows[0].claim_time??null;
      if(ts) return{claimed:isTodayUTC(ts),lastClaim:ts};
    }
  }
  return{claimed:false,lastClaim:null};
}

// ═══════════════════════════════════════════════════════════════
//  SMART CACHE CHECK — decides what needs re-fetching
// ═══════════════════════════════════════════════════════════════
function needsXPRefresh(acc){
  return !acc.xpFetchedAt || (Date.now()-acc.xpFetchedAt > XP_TTL);
}
function needsDailyRefresh(acc){
  return !acc.dailyFetchedAt || (Date.now()-acc.dailyFetchedAt > DAILY_TTL);
}

// ═══════════════════════════════════════════════════════════════
//  REFRESH ONE ACCOUNT — parallel fetches with smart caching
// ═══════════════════════════════════════════════════════════════
async function refreshOne(id, forceAll=false){
  const acc=accounts.find(a=>a.id===id);
  if(!acc) return;
  acc.status='loading';
  save(); renderTable();

  try{
    // Always-fresh: NFT count, LOOT balance, WAX balances, claim status
    // Smart-cached: XP (30d), daily loot (48h)
    const alwaysFetch=[
      fetchNFTCount(acc.wallet),
      fetchLootBal(acc.wallet),
      fetchWAX(acc.wallet),
      fetchClaimStatus(acc.wallet),
    ];

    const conditionalXP    = (forceAll||needsXPRefresh(acc))    ? fetchXP(acc.wallet)        : Promise.resolve(acc.xp||0);
    const conditionalDaily = (forceAll||needsDailyRefresh(acc)) ? fetchDailyLoot(acc.wallet) : Promise.resolve(acc.daily||0);

    const [nftsR, lootR, waxR, claimR, xpR, dailyR] = await Promise.allSettled([
      ...alwaysFetch, conditionalXP, conditionalDaily
    ]);

    const v=r=>r.status==='fulfilled'?r.value:null;

    const nfts  = v(nftsR)  ?? 0;
    const loot  = v(lootR)  ?? 0;
    const wax   = v(waxR)   ?? {liquid:0,cpu:0,net:0,staked:0,total:0};
    const claim = v(claimR) ?? {claimed:false,lastClaim:null};
    const xp    = v(xpR)    ?? (acc.xp||0);
    const daily = v(dailyR) ?? (acc.daily||0);

    acc.nfts       = nfts;
    acc.loot       = loot;
    acc.waxLiquid  = wax.liquid;
    acc.waxCPU     = wax.cpu;
    acc.waxNET     = wax.net;
    acc.waxStaked  = wax.staked;
    acc.waxTotal   = wax.total;
    acc.claimed    = claim.claimed;
    acc.lastClaim  = claim.lastClaim;
    acc.status     = claim.claimed?'claimed':'claimable';
    acc.fetchedAt  = Date.now();

    // Update XP only if we actually fetched it fresh
    if (forceAll||needsXPRefresh(acc)) {
      acc.xp          = xp;
      acc.rank        = getRank(xp);
      acc.xpFetchedAt = Date.now();
    }

    // Update daily only if we actually fetched it fresh
    if (forceAll||needsDailyRefresh(acc)) {
      // If history fetch returned 0, fall back to XP estimate
      acc.daily          = daily > 0 ? daily : Math.round(acc.xp * LOOT_PER_XP * 10)/10;
      acc.dailyFetchedAt = Date.now();
      acc.dailySource    = daily > 0 ? 'chain' : 'estimate';
    }

    log(`${acc.wallet}: NFT=${nfts} LOOT=${num(loot,0)} WAX=${num(wax.total,1)} daily=${num(acc.daily,1)} [${acc.dailySource||'?'}]`,
        claim.claimed?'w':'s');

  }catch(e){
    acc.status='error';
    log(`${acc.wallet}: ${e.message}`,'e');
  }

  save(); renderTable(); updateHero();
}

// ═══════════════════════════════════════════════════════════════
//  REFRESH ALL — batched parallel
// ═══════════════════════════════════════════════════════════════
async function refreshAll(forceAll=false){
  if(busy||!accounts.length) return;
  busy=true;
  document.getElementById('btn-ra').disabled=true;
  const wrap=document.getElementById('prog-wrap');
  const fill=document.getElementById('prog-fill');
  const txt =document.getElementById('prog-txt');
  wrap.style.display='block'; fill.style.width='0%';
  const total=accounts.length;
  let done=0;
  log(`Refreshing ${total} accounts (batch=${BATCH}, XP cached ${!forceAll?'30d':'forced'}, daily cached ${!forceAll?'48h':'forced'})...`,'i');
  toast(`Refreshing ${total} accounts...`);
  for(let i=0;i<accounts.length;i+=BATCH){
    const batch=accounts.slice(i,i+BATCH);
    batch.forEach(a=>{a.status='loading';});
    renderTable();
    await Promise.allSettled(batch.map(a=>refreshOne(a.id,forceAll)));
    done+=batch.length;
    fill.style.width=`${Math.round((done/total)*100)}%`;
    txt.textContent=`${done} / ${total}`;
    if(i+BATCH<accounts.length) await sleep(200);
  }
  wrap.style.display='none';
  busy=false;
  document.getElementById('btn-ra').disabled=false;
  const cl=accounts.filter(a=>a.status==='claimable').length;
  toast(`Done — ${cl}/${total} claimable`,'s');
  log(`Refresh complete. ${cl} claimable.`,'s');
  await fetchPrices();
  updateHero();
}

// ═══════════════════════════════════════════════════════════════
//  ADD / BULK / REMOVE
// ═══════════════════════════════════════════════════════════════
function togAdd(){
  const p=document.getElementById('add-panel');
  p.classList.toggle('open');
  if(p.classList.contains('open')){
    document.getElementById('bulk-panel').classList.remove('open');
    setTimeout(()=>document.getElementById('inp-w').focus(),50);
  }
}
function togBulk(){
  const p=document.getElementById('bulk-panel');
  p.classList.toggle('open');
  if(p.classList.contains('open')){
    document.getElementById('add-panel').classList.remove('open');
    setTimeout(()=>document.getElementById('bulk-ta').focus(),50);
  }
}

const parseW=s=>s.trim().toLowerCase().replace(/[^a-z0-9.]/g,'');
function mkAcc(wallet,alias=''){
  return{id:`${Date.now()}-${Math.random().toString(36).slice(2)}`,
    wallet,alias,nfts:0,xp:0,rank:getRank(0),
    loot:0,waxLiquid:0,waxCPU:0,waxNET:0,waxStaked:0,waxTotal:0,
    daily:0,dailySource:'',claimed:false,lastClaim:null,
    status:'loading',fetchedAt:null,xpFetchedAt:null,dailyFetchedAt:null};
}

async function addOne(){
  const w=parseW(document.getElementById('inp-w').value);
  const a=document.getElementById('inp-a').value.trim();
  if(!w){toast('Enter a wallet','e');return;}
  if(accounts.find(x=>x.wallet===w)){toast(`${w} already added`,'e');return;}
  document.getElementById('inp-w').value='';
  document.getElementById('inp-a').value='';
  const acc=mkAcc(w,a);
  accounts.push(acc);
  save();renderTable();updateHero();
  log(`Added: ${w}`,'i');toast(`Added ${w}`);
  if(!apiOk) await findEndpoints();
  if(apiOk) await refreshOne(acc.id,true);
}

async function bulkImport(){
  const lines=document.getElementById('bulk-ta').value
    .split('\n').map(l=>l.trim()).filter(Boolean);
  if(!lines.length){toast('Nothing to import','e');return;}
  let added=0,skip=0;
  const toRefresh=[];
  for(const line of lines){
    const parts=line.split(',');
    const w=parseW(parts[0]);
    const a=(parts[1]||'').trim();
    if(!w) continue;
    if(accounts.find(x=>x.wallet===w)){skip++;continue;}
    const acc=mkAcc(w,a);
    accounts.push(acc);
    toRefresh.push(acc.id);
    added++;
  }
  document.getElementById('bulk-ta').value='';
  document.getElementById('bulk-panel').classList.remove('open');
  save();renderTable();updateHero();
  log(`Bulk: +${added} added, ${skip} skipped`,'s');
  toast(`Imported ${added} accounts`,'s');
  if(!apiOk) await findEndpoints();
  if(apiOk){
    const toProc=accounts.filter(a=>toRefresh.includes(a.id));
    for(let i=0;i<toProc.length;i+=BATCH){
      const batch=toProc.slice(i,i+BATCH);
      await Promise.allSettled(batch.map(a=>refreshOne(a.id,true)));
      if(i+BATCH<toProc.length) await sleep(200);
    }
  }
}

function removeOne(id){
  const acc=accounts.find(a=>a.id===id);
  if(!acc||!confirm(`Remove ${acc.wallet}?`)) return;
  accounts=accounts.filter(a=>a.id!==id);
  save();renderTable();updateHero();
  log(`Removed: ${acc.wallet}`,'w');
}
function clearAll(){
  if(!confirm(`Remove all ${accounts.length} accounts?`)) return;
  accounts=[];save();renderTable();updateHero();log('Cleared','w');
}

// ═══════════════════════════════════════════════════════════════
//  EXPORT / IMPORT — full wallet list with all cached data
// ═══════════════════════════════════════════════════════════════

// ── EXPORT ──
// Saves wallet list + all cached data (XP, daily loot, balances)
// so you can restore on any device instantly without re-fetching
let _exportJson = '';

function exportData(){
  const payload = {
    version: 6,
    exported: new Date().toISOString(),
    note: 'Warsaken Tracker — export. Import on any device to restore all wallets.',
    accounts: accounts.map(a => ({
      // Core identity
      id:             a.id,
      wallet:         a.wallet,
      alias:          a.alias || '',
      // Cached chain data — preserved so new device doesn't re-fetch everything
      nfts:           a.nfts       || 0,
      xp:             a.xp         || 0,
      loot:           a.loot       || 0,
      waxLiquid:      a.waxLiquid  || 0,
      waxCPU:         a.waxCPU     || 0,
      waxNET:         a.waxNET     || 0,
      waxStaked:      a.waxStaked  || 0,
      waxTotal:       a.waxTotal   || 0,
      daily:          a.daily      || 0,
      dailySource:    a.dailySource|| '',
      claimed:        a.claimed    || false,
      lastClaim:      a.lastClaim  || null,
      // Cache timestamps — so smart cache knows what's fresh vs stale
      fetchedAt:      a.fetchedAt      || null,
      xpFetchedAt:    a.xpFetchedAt    || null,
      dailyFetchedAt: a.dailyFetchedAt || null,
      // Rank (derived but save it for instant display)
      rank: a.rank ? { label: a.rank.label, cls: a.rank.cls, idx: a.rank.idx, minXP: a.rank.minXP } : null,
    }))
  };
  _exportJson = JSON.stringify(payload, null, 2);

  // Show modal
  document.getElementById('ei-title').textContent = 'EXPORT WALLETS';
  document.getElementById('ei-sub').textContent   =
    `${accounts.length} accounts · ${new Date().toLocaleDateString()} — copy or download, then import on any device`;
  document.getElementById('ei-ta').value     = _exportJson;
  document.getElementById('ei-ta').readOnly  = true;
  document.getElementById('ei-actions').innerHTML = `
    <button class="btn prim sm" onclick="copyExport()">⎘ Copy to Clipboard</button>
    <button class="btn sm" onclick="downloadExport()">⬇ Download .json</button>
    <button class="btn sm" onclick="closeEI()">Close</button>`;
  openEI();
  log(`Exported ${accounts.length} accounts`,'s');
}

function copyExport(){
  navigator.clipboard.writeText(_exportJson).then(()=>{
    toast('Copied to clipboard!','s');
    log('Export copied to clipboard','s');
  }).catch(()=>{
    // Fallback for browsers that block clipboard
    document.getElementById('ei-ta').select();
    document.execCommand('copy');
    toast('Copied!','s');
  });
}

function downloadExport(){
  const blob = new Blob([_exportJson], {type:'application/json'});
  const url  = URL.createObjectURL(blob);
  const a    = document.createElement('a');
  const date = new Date().toISOString().slice(0,10);
  a.href     = url;
  a.download = `warsaken-tracker-${date}.json`;
  a.click();
  URL.revokeObjectURL(url);
  toast('Downloaded!','s');
  log('Export downloaded as .json file','s');
}

// ── IMPORT ──
// Accepts a previously exported JSON file
// Merges intelligently: skips duplicates, preserves cached data
function importData(event){
  const file = event.target.files[0];
  if (!file) return;
  // Reset file input so same file can be re-imported
  event.target.value = '';

  const reader = new FileReader();
  reader.onload = e => {
    try {
      const payload = JSON.parse(e.target.result);

      // Validate it's our format
      if (!payload.accounts || !Array.isArray(payload.accounts)) {
        toast('Invalid file — not a Warsaken Tracker export','e');
        return;
      }

      let added=0, skipped=0, updated=0;

      for (const imported of payload.accounts) {
        if (!imported.wallet) continue;
        const existing = accounts.find(a => a.wallet === imported.wallet);

        if (existing) {
          // Wallet already exists — update cached data if imported data is newer
          const importedFetch = imported.fetchedAt || 0;
          const existingFetch = existing.fetchedAt || 0;
          if (importedFetch > existingFetch) {
            // Imported data is fresher — merge it in
            Object.assign(existing, {
              alias:          imported.alias          || existing.alias,
              nfts:           imported.nfts           ?? existing.nfts,
              xp:             imported.xp             ?? existing.xp,
              loot:           imported.loot           ?? existing.loot,
              waxLiquid:      imported.waxLiquid      ?? existing.waxLiquid,
              waxCPU:         imported.waxCPU         ?? existing.waxCPU,
              waxNET:         imported.waxNET         ?? existing.waxNET,
              waxStaked:      imported.waxStaked      ?? existing.waxStaked,
              waxTotal:       imported.waxTotal       ?? existing.waxTotal,
              daily:          imported.daily          ?? existing.daily,
              dailySource:    imported.dailySource    || existing.dailySource,
              claimed:        imported.claimed        ?? existing.claimed,
              lastClaim:      imported.lastClaim      || existing.lastClaim,
              fetchedAt:      imported.fetchedAt      || existing.fetchedAt,
              xpFetchedAt:    imported.xpFetchedAt    || existing.xpFetchedAt,
              dailyFetchedAt: imported.dailyFetchedAt || existing.dailyFetchedAt,
              rank:           imported.rank           ? {...imported.rank} : existing.rank,
              status:         imported.claimed ? 'claimed' : 'claimable',
            });
            updated++;
          } else {
            skipped++;
          }
          continue;
        }

        // New wallet — add it with all its cached data intact
        const acc = mkAcc(imported.wallet, imported.alias || '');
        Object.assign(acc, {
          nfts:           imported.nfts           || 0,
          xp:             imported.xp             || 0,
          loot:           imported.loot           || 0,
          waxLiquid:      imported.waxLiquid      || 0,
          waxCPU:         imported.waxCPU         || 0,
          waxNET:         imported.waxNET         || 0,
          waxStaked:      imported.waxStaked      || 0,
          waxTotal:       imported.waxTotal       || 0,
          daily:          imported.daily          || 0,
          dailySource:    imported.dailySource    || '',
          claimed:        imported.claimed        || false,
          lastClaim:      imported.lastClaim      || null,
          fetchedAt:      imported.fetchedAt      || null,
          xpFetchedAt:    imported.xpFetchedAt    || null,
          dailyFetchedAt: imported.dailyFetchedAt || null,
          rank:           imported.rank ? {...imported.rank, idx: imported.rank.idx||0} : getRank(imported.xp||0),
          status:         imported.claimed ? 'claimed' : (imported.fetchedAt ? 'claimable' : 'loading'),
        });
        accounts.push(acc);
        added++;
      }

      save(); renderTable(); updateHero();
      const msg = `Import done: ${added} added, ${updated} updated, ${skipped} already current`;
      toast(msg,'s'); log(msg,'s');

      // Only fetch data for wallets that have no cached data at all
      const needsFetch = accounts.filter(a => !a.fetchedAt);
      if (needsFetch.length > 0 && apiOk) {
        log(`Fetching data for ${needsFetch.length} new wallets...`,'i');
        (async()=>{
          for(let i=0;i<needsFetch.length;i+=BATCH){
            const batch=needsFetch.slice(i,i+BATCH);
            await Promise.allSettled(batch.map(a=>refreshOne(a.id,true)));
            if(i+BATCH<needsFetch.length) await sleep(200);
          }
        })();
      }

    } catch(err) {
      toast('Failed to parse file — not a valid Warsaken export','e');
      log(`Import error: ${err.message}`,'e');
    }
  };
  reader.readAsText(file);
}

// ── Modal helpers ──
function openEI(){
  const m=document.getElementById('ei-modal');
  m.style.display='flex';
  setTimeout(()=>document.getElementById('ei-ta').select?.(),100);
}
function closeEI(){
  document.getElementById('ei-modal').style.display='none';
  _exportJson='';
}

// ═══════════════════════════════════════════════════════════════
//  FILTER / SORT
// ═══════════════════════════════════════════════════════════════
function setF(f,el){
  activeF=f;
  document.querySelectorAll('.ftab').forEach(t=>t.classList.remove('on'));
  el.classList.add('on');renderTable();
}
const SRD={claimable:0,loading:1,error:2,claimed:3};
function srt(k){
  if(srtKey===k) srtDir*=-1;
  else{srtKey=k;srtDir=-1;}
  document.querySelectorAll('th').forEach((th,i)=>{
    th.classList.remove('srt');
    const a=th.querySelector('.arr');
    if(a) a.textContent='↕';
  });
  const keys=['wallet','rank','nfts','xp','daily','loot','waxTotal','waxLiquid','waxStaked','status','lastClaim'];
  const idx=keys.indexOf(k);
  if(idx>=0){
    const ths=document.querySelectorAll('th');
    if(ths[idx]){
      ths[idx].classList.add('srt');
      const a=ths[idx].querySelector('.arr');
      if(a) a.textContent=srtDir===1?'↑':'↓';
    }
  }
  renderTable();
}

// ═══════════════════════════════════════════════════════════════
//  RENDER TABLE
// ═══════════════════════════════════════════════════════════════
const fmtDate=ts=>{
  try{
    const d=new Date(ts.includes('T')||ts.endsWith('Z')?ts:ts+'Z');
    return`${pad(d.getUTCDate())}/${pad(d.getUTCMonth()+1)} ${pad(d.getUTCHours())}:${pad(d.getUTCMinutes())}`;
  }catch(e){return ts;}
};

function cacheIndicator(ts, ttl){
  if(!ts) return '<span class="ci none" title="Not fetched yet"></span>';
  const age=Date.now()-ts;
  if(age<ttl*0.5) return '<span class="ci fresh" title="Fresh"></span>';
  if(age<ttl)     return '<span class="ci stale" title="Getting stale"></span>';
  return '<span class="ci none" title="Needs refresh"></span>';
}

function renderTable(){
  const tbody=document.getElementById('tbl-body');
  const q=document.getElementById('search').value.trim().toLowerCase();
  let rows=[...accounts];
  if(activeF!=='all') rows=rows.filter(a=>a.status===activeF);
  if(q) rows=rows.filter(a=>a.wallet.includes(q)||(a.alias||'').toLowerCase().includes(q));
  rows.sort((a,b)=>{
    let va,vb;
    switch(srtKey){
      case 'wallet':    va=a.wallet;        vb=b.wallet;        break;
      case 'rank':      va=a.rank?.idx||0;  vb=b.rank?.idx||0;  break;
      case 'nfts':      va=a.nfts;          vb=b.nfts;          break;
      case 'xp':        va=a.xp;            vb=b.xp;            break;
      case 'daily':     va=a.daily;         vb=b.daily;         break;
      case 'loot':      va=a.loot;          vb=b.loot;          break;
      case 'waxTotal':  va=a.waxTotal;      vb=b.waxTotal;      break;
      case 'waxLiquid': va=a.waxLiquid;     vb=b.waxLiquid;     break;
      case 'waxStaked': va=a.waxStaked;     vb=b.waxStaked;     break;
      case 'lastClaim': va=a.lastClaim||''; vb=b.lastClaim||''; break;
      case 'status':    va=SRD[a.status]??9;vb=SRD[b.status]??9;break;
      default:          va=a.loot;          vb=b.loot;
    }
    if(va<vb) return -srtDir;
    if(va>vb) return  srtDir;
    return 0;
  });

  document.getElementById('btn-ra').style.display=accounts.length?'inline-flex':'none';
  document.getElementById('btn-cl').style.display=accounts.length?'inline-flex':'none';

  if(!accounts.length){
    tbody.innerHTML=`<tr><td colspan="12"><div class="empty">
      <div class="empty-icon">🎖</div>
      <div class="empty-ttl">No Accounts Added</div>
      <div class="empty-sub">Bulk import your WAX wallets to start tracking</div>
      <button class="btn prim sm" onclick="togBulk()">⬆ Bulk Import</button>
    </div></td></tr>`;
    return;
  }
  if(!rows.length){
    tbody.innerHTML=`<tr><td colspan="12" style="text-align:center;padding:26px;color:var(--text3);font-family:'DM Mono',monospace;font-size:.74rem;">No accounts match filter</td></tr>`;
    return;
  }

  const pills={
    claimable:`<span class="pill pc"><span class="pdot"></span>CLAIMABLE</span>`,
    claimed:  `<span class="pill pd"><span class="pdot"></span>CLAIMED</span>`,
    loading:  `<span class="pill pl"><span class="pdot"></span>LOADING</span>`,
    error:    `<span class="pill pe"><span class="pdot"></span>ERROR</span>`,
  };
  const rcls={claimable:'sc',claimed:'sd',loading:'sl',error:'se'};
  const sh=(w='56%')=>`<div class="shim" style="width:${w}"></div>`;

  tbody.innerHTML='';
  rows.forEach(acc=>{
    const rank=acc.rank||getRank(0);
    const ri=rank.idx||0;
    const next=RANKS[ri+1];
    const pct=next?Math.min(100,Math.round(((acc.xp-rank.minXP)/(next.minXP-rank.minXP))*100)):100;
    const L=acc.status==='loading';
    const lootWaxVal=toWAX(acc.loot);
    const dailyWaxVal=toWAX(acc.daily);
    const sourceTag=acc.dailySource==='chain'
      ?`<span style="color:var(--green);font-size:.55rem">●chain</span>`
      :acc.dailySource==='estimate'
        ?`<span style="color:var(--orange);font-size:.55rem">~est</span>`
        :'';

    const tr=document.createElement('tr');
    tr.className=rcls[acc.status]||'';
    tr.innerHTML=`
      <td>
        <div class="wlt">${acc.wallet}</div>
        ${acc.alias?`<div class="ali">${acc.alias}</div>`:''}
      </td>
      <td>${L?sh('48%'):`
        <span class="rbadge ${rank.cls}">${rank.label}</span>
        <div class="xpt"><div class="xpf" style="width:${pct}%"></div></div>
        ${cacheIndicator(acc.xpFetchedAt,XP_TTL)}`}
      </td>
      <td>${L?sh('30%'):`<span class="mn go">${acc.nfts}</span>`}</td>
      <td>${L?sh():`<span class="mn">${acc.xp.toLocaleString()}</span>`}</td>
      <td>${L?sh():`
        <div><span class="mn pu">${num(acc.daily,1)}</span> ${sourceTag}</div>
        <div class="sv">${dailyWaxVal?`≈ ${num(dailyWaxVal,1)} WAX · ${toUSD(acc.daily,PC.lootUsd)}`:''}
        ${cacheIndicator(acc.dailyFetchedAt,DAILY_TTL)}</div>`}
      </td>
      <td>${L?sh():`
        <span class="mn go">${num(acc.loot,1)}</span>
        <div class="sv">${lootWaxVal?`≈ ${num(lootWaxVal,1)} WAX · ${toUSD(acc.loot,PC.lootUsd)}`:''}</div>`}
      </td>
      <td>${L?sh():`
        <span class="mn bl">${num(acc.waxTotal,2)}</span>
        <div class="sv">${toUSD(acc.waxTotal,PC.waxUsd)}</div>`}
      </td>
      <td>${L?sh():`<span class="mn bl">${num(acc.waxLiquid,2)}</span>`}</td>
      <td>${L?sh():`
        <span class="mn pu">${num(acc.waxStaked,2)}</span>
        <div class="sv">CPU:${num(acc.waxCPU,2)} NET:${num(acc.waxNET,2)}</div>`}
      </td>
      <td>${pills[acc.status]||'—'}</td>
      <td><span class="mn" style="font-size:.7rem;color:var(--text2)">${acc.lastClaim?fmtDate(acc.lastClaim):'—'}</span></td>
      <td>
        <div class="acts">
          ${!L?`<a href="https://warsaken.cards" target="_blank" rel="noopener" class="btn sm">Claim ↗</a>`:
               `<button class="btn sm" disabled>···</button>`}
          <button class="btn sm" onclick="refreshOne('${acc.id}',false)" ${L?'disabled':''} title="Smart refresh">↻</button>
          <button class="btn sm dng" onclick="removeOne('${acc.id}')" title="Remove">✕</button>
        </div>
      </td>`;
    tbody.appendChild(tr);
  });
}

// ═══════════════════════════════════════════════════════════════
//  HERO STATS
// ═══════════════════════════════════════════════════════════════
function updateHero(){
  const cl    = accounts.filter(a=>a.status==='claimable').length;
  const done  = accounts.filter(a=>a.status==='claimed').length;
  const nfts  = accounts.reduce((s,a)=>s+(a.nfts||0),0);
  const loot  = accounts.reduce((s,a)=>s+(a.loot||0),0);
  const wax   = accounts.reduce((s,a)=>s+(a.waxTotal||0),0);
  const staked= accounts.reduce((s,a)=>s+(a.waxStaked||0),0);
  const daily = accounts.reduce((s,a)=>s+(a.daily||0),0);

  // LOOT → WAX conversion
  const lootInWax  = PC.lootWax  ? loot  * PC.lootWax  : 0;
  const dailyInWax = PC.lootWax  ? daily * PC.lootWax  : 0;

  // Total portfolio WAX value = liquid WAX + staked WAX + LOOT converted to WAX
  const totalWaxValue = wax + lootInWax;

  document.getElementById('h-accs').textContent     = accounts.length;
  document.getElementById('h-accs-sub').textContent = `${cl} claimable`;
  document.getElementById('h-claim').textContent    = cl;
  document.getElementById('h-done-sub').textContent = `${done} already claimed`;
  document.getElementById('h-nfts').textContent     = nfts.toLocaleString();

  document.getElementById('h-loot').textContent     = num(loot,0);
  document.getElementById('h-loot-usd').textContent =
    lootInWax  ? `≈ ${num(lootInWax,1)} WAX · ${toUSD(loot,PC.lootUsd)||'$0'}` : `≈ $0 USD`;

  document.getElementById('h-wax').textContent      = num(wax,1);
  document.getElementById('h-wax-usd').textContent  = toUSD(wax,PC.waxUsd) ? `≈ ${toUSD(wax,PC.waxUsd)} USD` : '≈ $0 USD';

  document.getElementById('h-staked').textContent   = num(staked,1);

  document.getElementById('h-daily').textContent    = num(daily,0);
  document.getElementById('h-daily-usd').textContent= dailyInWax ? `≈ ${num(dailyInWax,1)} WAX/day` : 'from blockchain txns';

  document.getElementById('h-daily-wax').textContent    = dailyInWax ? num(dailyInWax,2) : '—';
  document.getElementById('h-daily-wax-usd').textContent = dailyInWax
    ? `≈ ${toUSD(dailyInWax,PC.waxUsd)||'$0'} USD/day`
    : PC.lootWax ? '≈ $0 USD/day' : 'awaiting price...';
}

// ═══════════════════════════════════════════════════════════════
//  KEYBOARD SHORTCUTS
// ═══════════════════════════════════════════════════════════════
document.addEventListener('keydown',e=>{
  if(e.key==='Escape'){
    document.getElementById('add-panel').classList.remove('open');
    document.getElementById('bulk-panel').classList.remove('open');
    closeEI();
  }
  if(!e.target.matches('input,textarea')){
    if(e.key==='n') togAdd();
    if(e.key==='r') refreshAll(false);
    if(e.key==='b') togBulk();
  }
});
document.getElementById('inp-w').addEventListener('keydown',e=>{if(e.key==='Enter')addOne();});

// ═══════════════════════════════════════════════════════════════
//  BOOT
// ═══════════════════════════════════════════════════════════════
(async()=>{
  log('Warsaken Tracker v6 — smart cache engine active','i');
  log(`XP cache: 30 days · Daily LOOT cache: 48 hours · Balance: always fresh`,'i');
  renderTable();updateHero();
  const [,ok]=await Promise.all([fetchPrices(),findEndpoints()]);
  if(ok&&accounts.length>0){
    log(`Auto-refreshing ${accounts.length} accounts...`,'i');
    await refreshAll(false);
  }
  setInterval(async()=>{await fetchPrices();updateHero();},PRICE_TTL);
})();

// ── FOOTER WALLET COPY ──
function copyWallet(){
  const addr = 'zh3b2.wam';
  navigator.clipboard.writeText(addr).then(()=>{
    const el = document.getElementById('donate-confirm');
    el.textContent = '✓ Copied to clipboard!';
    setTimeout(()=>{ el.textContent=''; }, 2500);
  }).catch(()=>{
    // fallback
    const ta = document.createElement('textarea');
    ta.value = addr;
    document.body.appendChild(ta);
    ta.select();
    document.execCommand('copy');
    document.body.removeChild(ta);
    const el = document.getElementById('donate-confirm');
    el.textContent = '✓ Copied!';
    setTimeout(()=>{ el.textContent=''; }, 2500);
  });
}
</script>
</body>
</html>
